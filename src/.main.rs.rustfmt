use std::io::{Read, Seek};
//use std::path::Path;
use std::path::PathBuf;
use cfb;
use std::fmt;
use byteorder::{LittleEndian, ReadBytesExt};
use uuid::Uuid;

mod interchange_object;

type OMByteOrder = u8;
type OMVersion = u8;
type OMPropertyCount = u16;
type OMPropertyId = u16;
type OMStoredForm = u16;
type OMPropertySize = u16;
//type OMKeySize = u8;
//type OMPropertyTag = u16;


struct PropertyDescriptor {
    pid : OMPropertyId,
    stored_form: OMStoredForm,
    value: Box<Vec<u8>>
}


impl fmt::Debug for PropertyDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PropertyDescriptor")
            .field("pid", &format!("{:x}", self.pid))
            .field("stored_form",&self.stored_form)
            .field("len(value)", &self.value.len())
            .finish()
    }
}


struct AAFFile<F> {
    f : cfb::CompoundFile<F>
}

impl<F> AAFFile<F> {
    pub fn interchange_objects(&mut self) -> InterchangeObjectDescriptorIter<cfb::Entries> {
        let entries = self.f.walk();
        InterchangeObjectDescriptorIter(entries)
    }
}


impl<F: Read + Seek> AAFFile<F> {

    fn parse_properties_file(mut stream: cfb::Stream<F>) -> Vec<PropertyDescriptor> {
        let bom = stream.read_u8().unwrap() as OMByteOrder;
        assert_eq!(bom, 0x4c, "BOM is invalid");

        let _version = stream.read_u8().unwrap() as OMVersion;
        let property_count = stream.read_u16::<LittleEndian>().unwrap() as OMPropertyCount;
        
        let mut retval = Vec::with_capacity(property_count as usize);
        
        for _ in 0..property_count {
            let pid = stream.read_u16::<LittleEndian>().unwrap() as OMPropertyId;
            let stored_form = stream.read_u16::<LittleEndian>().unwrap() as OMStoredForm; 
            let property_size = stream.read_u16::<LittleEndian>().unwrap() as OMPropertySize;
            let value = vec![0; property_size as usize];
            // This appears to be the wrong place to do this...
            // stream.read_exact(&mut value).unwrap();
            
            let prop = PropertyDescriptor { pid, stored_form, value: Box::new(value)} ;
            retval.push(prop);
        }
        
        retval
    }

    fn properties(&mut self, object: &InterchangeObjectDescriptor) -> Vec<PropertyDescriptor> {
        let properties_path = object.path.join("properties");
        let stream = self.f.open_stream(&properties_path).unwrap();
        Self::parse_properties_file(stream)
    }
}

fn main() {
    let test_path =  "testmedia/AAF_Test_1/AAF_Test_1.aaf";
    let comp = cfb::open(test_path).unwrap();
    
    
    let mut f = AAFFile { f: comp };
    let mut objects : Vec<InterchangeObjectDescriptor> = vec![];
    { 
        for e in f.interchange_objects() {
            objects.push(e)
        }
    }
    
    let mut objects_properties : Vec<(InterchangeObjectDescriptor,
                                      Vec<PropertyDescriptor>)> = vec![];

    {
        for e in objects.into_iter() {
            let properties = f.properties(&e);
            objects_properties.push((e, properties));
        }
    }

    for e in objects_properties.into_iter() {
        println!("Object: {:?}", e.0);
        for p in e.1.into_iter() {
            println!("- {:?}", p);
        }
    }
}
